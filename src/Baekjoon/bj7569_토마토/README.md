# 토마토

## 문제 이해
토마토가 상자에 담겨 있고,가로가 M, 세로가 N, 높이가 H이다.  
각각의 칸에 토마토가 들어있거나 들어있지 않고, 익거나 익지 않았다.  
이 때 한 토마토가 익으면 하루가 지나고 그 토마토의 앞, 뒤, 양 옆, 위, 아래의 토마토가 익게된다.  
창고에 보관된 토마토가 모두 다 익으려면 필요한 최소 일수를 구해야 한다.

## 문제 해결
토마토는 3차원 배열을 만들고 그에 대해 BFS를 진행한다.  
M, N, H가 모두 100이하 이므로 전부 탐색해도 시간 초과가 나지는 않을 것으로 보인다.  

### 3중 배열
3차원 배열은 처음 사용해 보았다.
int [ ][ ][ ] 에서 순서대로 [height] [row] [column]이라고 한다.  
처음 생성하고 모든 칸은 Arrays.fill()을 이용하여 모두 -1로 채웠다.  
이를 통해 가장 바깥 부분은 -1로 되어 따로 처리를 안해줘도 더 바깥쪽으로 탐색하러 가지 않는다.  

### BFS
위치를 표시하기 위해 Location이라는 static class를 생성했다. 위치 정보를 가진다.
BFS를 진행하기 전 존재하는 토마토 수와 익은 토마토 수가 동일하면 0을 출력하고 종료 하도록 했다.  
처음에 입력을 읽으면서 익은 토마토의 위치는 queue에 넣었다.  
BFS를 돌 때 하루에 익는 토마토를 한정하는 게 어려웠는데, 이는 한 번 돌 때마다 시작하는 queue의 사이즈만큼만 돌게 하여 해결했다.  
처음 시작할 때 4개의 토마토가 queue에 들어있으면 4개만 꺼내서 하루에 익는 토마토의 양을 한정했다.  
한 번 돌고나면(하루가 지나고) 다시 queue를 돌기 위해 확인하면 이 때는 앞서 4개의 토마토 주변의 토마토들의 위치들만 들어있을 것이므로, 이 때도 다시 queue 사이즈만 큼만 탐색하도록 했다.  
  
BFS의 진행은 다음과 같다.
1. 큐에서 위치정보를 꺼낸다.
2. 방문했던 곳인지 확인하고 방문했던 곳이면 넘어간다.
3. 방문하지 않았던 곳이면 방문체크를 하고 done(익은 토마토의 개수)을 +1해주고 주변을 탐색해 0인 칸을 큐에 넣는다.

이걸 큐가 비어 있을 때 까지 반복한다.  
이 때 day를 +1해주는 건 처음 큐의 사이즈만큼 탐색하고 나면 day를 +1 해준다.  
탐색 도중 익은 토마토 개수와 총 토마토 개수가 동일하면 day를 return한다.
day가 전체 토마토 박스 칸 수 보다 커지면 -1을 return한다.



## 문제 링크
https://www.acmicpc.net/problem/7569

## 추가적으로 알게 된 부분
자바의 3중 배열 활용법